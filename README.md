# PythonWeb
This repository for learning Python Web

**Модуль 1**

Напишіть класи серіалізації контейнерів з даними Python у json, bin файли. Самі класи мають відповідати загальному інтерфейсу (абстрактному базовому класу) SerializationInterface.
Напишіть клас метаклас Meta, який усім класам, для кого він буде метакласом, встановлює порядковий номер. 

**Модуль 2**

Намалюйте UML діаграму вашого курсового застосунку "Персональний помічник". Для роботи можете скористатися безкоштовним draw.io або будь-яким іншим зручним для вас застосунком.
Ваш курсовий застосунок зараз працює в консольному режимі і взаємодіє з користувачем за допомогою команд в консолі. Застосунок потрібно розвивати і частиною застосунку, що найчастіше змінюється, зазвичай, є інтерфейс користувача (консоль поки що). Модифікуйте код вашого застосунку, щоб представлення інформації користувачеві (виведення карток з контактами користувача, нотатками, сторінка з інформацією про доступні команди) було легко змінити. Для цього треба описати абстрактний базовий клас для представлень користувача і конкретні реалізації, які наслідують базовий клас і реалізують консольний інтерфейс. Надалі ми розширюватимемо застосунок, додаючи туди Web-інтерфейс.

**Модуль 3**

Зараз ваш проект "Персональний помічник", швидше за все, існує як пакет у системі, встановлений глобально, і використовує версію Python, яка встановлена в системі зі встановленими в системі пакетами. Скористайтеся будь-яким зручним інструментом (pipenv, conda, poetry) для створення віртуального оточення для вашої програми. Зафіксуйте версію Python у цьому оточенні (вкажіть явно: який Python слід використовувати) та налаштуйте ваше робоче середовище (IDE) для роботи зі створеним оточенням.
Створіть Dockerfile, в якому встановіть "Персональний помічник" і запустіть його як окрему програму в окремому контейнері.

**Модуль 4**

Напишіть програму обробки папки "Хлам", яка сортує файли у вказаній папці за розширеннями з використанням декількох потоків. Прискорьте обробку великих каталогів з великою кількістю вкладених папок та файлів за рахунок паралельного виконання обходу всіх папок в окремих потоках. Найвитратнішим за часом буде перенесення файлу та отримання списку файлів у папці (ітерація вмісту каталогу). Щоб прискорити перенесення файлів, його можна виконувати в окремому потоці або пулі потоків. Це тим паче зручніше, що результат цієї операції ви в застосунку не обробляєте і можна не збирати жодних результатів. Щоб прискорити обхід вмісту каталогу з кількома рівнями вкладеності, ви можете обробку кожного підкаталогу виконувати в окремому потоці або передавати обробку в пул потоків.

**Модуль 5**

Напишіть реалізацію функції factorize, яка приймає список чисел та повертає список чисел, на які числа із вхідного списку діляться без залишку.

Реалізуйте синхронну версію та виміряйте час виконання.

Потім покращіть продуктивність вашої функції, реалізувавши використання кількох ядер процесора для паралельних обчислень, і виміряйте час виконання знову.

Для перевірки правильності роботи алгоритму самої функції можете скористатися тестом:
def factorize(*number):
    # YOUR CODE HERE
    raise NotImplementedError()

a, b, c, d  = factorize(128, 255, 99999, 10651060)

assert a == [1, 2, 4, 8, 16, 32, 64, 128]
assert b == [1, 3, 5, 15, 17, 51, 85, 255]
assert c == [1, 3, 9, 41, 123, 271, 369, 813, 2439, 11111, 33333, 99999]
assert d == [1, 2, 4, 5, 7, 10, 14, 20, 28, 35, 70, 140, 76079, 152158, 304316, 380395, 532553, 760790, 1065106, 1521580, 2130212, 2662765, 5325530, 10651060]

**Модуль 6**

Напишіть програму обробки папки "Хлам", яка сортує файли у вказаній папці за розширеннями за допомогою asyncio. Щоб переміщувати та перейменовувати файли, скористайтеся асинхронною версією pathlib: [aiopath.](https://pypi.org/project/aiopath/)

**Модуль 7**

Напишіть застосунок для відправлення текстових повідомлень між комп'ютерами в одній локальній мережі за допомогою пакета socket. Повідомлення може бути просто текстом, рядком, надісланим мережею, можна не ускладнювати протокол, додаючи HTTP або HTML. Для цього вам потрібно написати код для клієнта, який ініціалізуватиме комунікацію та код сервера, який прийматиме повідомлення від клієнтів. Щоб спростити програму, можете не використовувати з'єднання більше, ніж для одного повідомлення.

Клієнт надсилає повідомлення серверу на вказаний IP, сервер відповідає OK та закриває з'єднання. Клієнт, отримавши OK, знає, що повідомлення успішно доставлено.

Щоб відповісти відправнику першого повідомлення, весь цикл повторюється, але інший комп'ютер виступає у ролі клієнта.

Критерії приймання
вам відомі IP адреси комп'ютерів та порти, на яких запущено ваш застосунок;
застосунок повинен давати можливість обмінюватися текстовими повідомленнями між двома комп'ютерами;
застосунок завершує всі з'єднання та звільняє всі системні ресурси за будь-якого сценарію завершення роботи;

**Модуль 8**

Реалізувати схему бази даних, яка містить:

- Перелік студентів.
- Перелік груп.
- Перелік предметів із зазначенням викладача, який читає предмет. У кожного студента є оцінки з предметів із зазначенням, коли оцінка отримана.
- Створити базу даних та заповнити випадковими даними (~30 студентів, 3 групи, 5 предметів, 3 викладачі, по 20 оцінок у кожного студента з усіх предметів).

Зробити наступні вибірки з бази:

- 5 студентів із найбільшим середнім балом з усіх предметів.
- 1 студент із найвищим середнім балом з одного предмета.
- Середній бал в групі по одному предмету.
- Середній бал у потоці. 
– Які курси читає викладач.
- Список студентів у групі.
- Оцінки студентів у групі з предмета.
- Оцінки студентів у групі з предмета на останньому занятті.
- Список курсів, які відвідує студент.
- Список курсів, які студенту читає викладач. 
– Середній бал, який викладач ставить студенту.
- Середній бал, який ставить викладач.

**Модуль 9**

Реалізуйте зберігання інформації для вашого "Персонального помічника" в базі даних SQLite.
Реалізуйте зберігання книги контактів з email адресами, телефонами, іменами в базі даних.

Критерії прийому:

- база даних описується за допомогою SQLAlchemy моделей
- таблиці в базі даних створюються та змінюються за допомогою Alembic
- пошук необхідної інформації відбувається за допомогою запитів до бази даних

**Модуль 10**

- Реалізуйте LRU кеш для Python коду, який використовує Redis.
- Реалізуйте сховище інформації для "Персонального помічника" за допомогою Mongo DB.
